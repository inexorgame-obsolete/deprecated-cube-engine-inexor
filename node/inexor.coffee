InexorService = require 'inexor/InexorService'
Async = require 'async'
F = require 'inexor/functional'

# High Level interface for communicating with Inexor
#
# The module always exposes the singleton value
class Inexor
  # The singleton value;
  #
  # @see @getSingleton
  # @return [Inexor]
  @singleton_value: null

  # Get or create the singleton instance
  #
  # This is what the module exposes
  #
  # @return [Inexor] The singleton value
  @getSingleton: ->
    Inexor.singleton_value ||= new Inexor

  # List of the cubescript function bindings generated by @C
  # This is used for the purpose of binding them to THIS on
  # construction
  @cbs_generated: []

  # The underlying InexorService
  #
  # @return [InexorService]
  service: null

  # The messages; taken from @service.messages
  #
  # TODO: Type?
  messages: null

  # Create one
  #
  # @param [InexorService] @service The underlying service
  constructor: (@service = new InexorService) ->
    @messages = @service.messages

    # Manuall bind => the Cubescript functions generated
    # with Inexor.C()
    for fn in Inexor.cbs_generated
      @[fn] = F.bind @[fn], @

  # Evaluate some cubescript in inexor
  #
  # @param [string] code The code to evaluate
  # @param [Function(Error/null, Int/Float/String/Null)]
  #   Callback, with the first argument being an error if
  #   one occured and the second being the cubescripts
  #   return value
  eval: (code, cb=->) =>
    msg = new @messages.Cubescript code: code
    @service.EvalCubescript msg, (a...) ->
      m = a[0]

      cb(m) if m instanceof Error

      data = m.s || m.i || m.f
      cb null, data

  # Metasyntax to provide binding to cubescript functions
  #
  # This injects a function called `jname` into Inexor::
  # that calls a cubescript function named `cname` with argn
  # arguments.
  #
  # This function should only be used inside the body of
  # inexor.
  #
  # Example:
  #
  #   class Inexor
  #     ...
  #     C "echo", 1, "print"
  #   ...
  #   inexor = new Inexor
  #   inexor.print "asdf" # Prints asdf on the inexor
  #   console
  #
  # @param [String] cname Cubescript name of the function
  # @param [Int] argn Number of arguments that function takes
  # @param [String] jname Javascript name of that function
  # @param [Function] rmap Optionally transform the return value
  #
  @C: (cname, argn, jname=cname, rmap=(x)->x) ->
    @.cbs_generated.push jname
    @::[jname] = (argv...) ->
      cb = argv[argn] || (->)
      cbs_args = argv[0...argn]
      @eval "#{cname} #{cbs_args.join " "}", (err, x) ->
        return cb err, null if err
        cb null, rmap x

  # Get the name of a connected client
  #
  # @param [Int] First The client number of the client
  # @param [Function(Error/Null, String/Null)] Second
  #   callback with the first parameter being an error if
  #   one occured and the second being the name of the
  #   connected client or Null if there is no such client
  @C "getclientname", 1, "clientName"

  # Get the team of a connected client
  #
  # @param [Int] First, The client number of the client
  # @param [Function(Error/Null, String/Null)] Second
  #   callback with the first parameter being an error if
  #   one occurred and the second being the team of the
  #   connected client or Null if there is no such client
  @C "getclientteam", 1, "clientTeam"

  # Check whether a client is spectating
  #
  # @param [Int] First, The client number of the client
  @C "isspectator", 1, "spectating", (x) ->
    Boolean Number x

  # List the client numbers of all connected client numbers
  #
  # @param [Error, Function(Array<Int>)] The callback, with
  #  an error and the other argument being a list of client
  #  numbers
  @C "listclients 1 1", 0, "listClientnos", (x) ->
    x.split(" ").map Number

  # Add a bot with a specific skill level
  #
  # @param [Int] 1. Skill level. value between 0 and 100
  @C "addbot", 1

  # List the clients connected
  #
  # The format returned is a list of Objects with the fields
  # clientnum, name, team and spectating
  #
  # @param [Function(Error/Null, players)] The callback
  listClients: (cb) =>
    @listClientnos (err, nos) =>
      return cb err, null if err
      para = Array \
        ((cb) => Async.map nos, @clientName, cb),
        ((cb) => Async.map nos, @clientTeam, cb),
        ((cb) => Async.map nos, @spectating, cb)
      Async.parallel para, (err, [names, teams, spec]) ->
        return cb err, null if err
        # TODO: Sanity checks?
        # TODO: Client abstraction
        cb null, nos.map (num, i) ->
          clientnum: num
          name: names[i]
          team: teams[i]
          spectating: spec[i]

module.exports = Inexor.getSingleton()
